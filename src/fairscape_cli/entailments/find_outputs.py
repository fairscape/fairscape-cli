import pathlib
import json
from typing import List, Dict, Tuple, Set, Any

def extract_datasets_from_graph(graph: List[Dict]) -> List[Tuple[str, bool]]:
    """
    Extract all datasets from the @graph with a flag indicating if they were generated by a computation.
    
    Returns:
        List of tuples: (dataset_id, has_generatedBy)
    """
    datasets = []
    for entity in graph:
        if entity.get("@type") == "https://w3id.org/EVI#Dataset":
            dataset_id = entity.get("@id")
            has_generated_by = bool(entity.get("generatedBy"))
            datasets.append((dataset_id, has_generated_by))
    return datasets

def extract_samples_from_graph(graph: List[Dict]) -> List[str]:
    """
    Extract all sample @ids from the @graph.
    
    Returns:
        List of sample @ids
    """
    samples = []
    for entity in graph:
        entity_type = entity.get("@type")
        if entity_type == "https://w3id.org/EVI#Sample" or entity_type == "EVI:Sample":
            sample_id = entity.get("@id")
            if sample_id:
                samples.append(sample_id)
    return samples

def extract_used_datasets_from_computations(graph: List[Dict]) -> Set[str]:
    """
    Extract all usedDataset @ids from computations in the @graph.
    
    Returns:
        Set of dataset @ids that are used by computations
    """
    used_datasets = set()
    for entity in graph:
        entity_type = entity.get("@type")
        if entity_type == "https://w3id.org/EVI#Computation" or entity_type == "EVI:Computation":
            used_dataset_list = entity.get("usedDataset", [])
            for dataset_ref in used_dataset_list:
                if isinstance(dataset_ref, dict) and "@id" in dataset_ref:
                    used_datasets.add(dataset_ref["@id"])
                elif isinstance(dataset_ref, str):
                    used_datasets.add(dataset_ref)
    return used_datasets

def calculate_inputs_outputs(graph: List[Dict]) -> Tuple[List[Dict[str, str]], List[Dict[str, str]]]:
    """
    Calculate the inputs and outputs for an RO-Crate based on its @graph.
    
    Inputs are:
    - All samples
    - Datasets that are in usedDataset but not generated by a computation
    - Datasets referenced in usedDataset but not defined in @graph
    - Datasets that are neither generated nor used (standalone datasets)
    
    Outputs are:
    - All datasets that were not used by any computation
    
    Returns:
        Tuple of (inputs, outputs) where each is a list of dicts with "@id" key
    """
    datasets = extract_datasets_from_graph(graph)
    samples = extract_samples_from_graph(graph)
    used_dataset_ids = extract_used_datasets_from_computations(graph)
    
    dataset_dict = {dataset_id: has_generated_by for dataset_id, has_generated_by in datasets}
    all_dataset_ids = set(dataset_dict.keys())
    
    inputs = []
    outputs = []
    
    for sample_id in samples:
        inputs.append({"@id": sample_id})
    
    for used_dataset_id in used_dataset_ids:
        if used_dataset_id in dataset_dict:
            if not dataset_dict[used_dataset_id]:
                inputs.append({"@id": used_dataset_id})
        else:
            inputs.append({"@id": used_dataset_id})
    
    for dataset_id, has_generated_by in datasets:
        if dataset_id not in used_dataset_ids:
            outputs.append({"@id": dataset_id})
            if not has_generated_by:
                inputs.append({"@id": dataset_id})
    
    seen_input_ids = set()
    unique_inputs = []
    for inp in inputs:
        if inp["@id"] not in seen_input_ids:
            seen_input_ids.add(inp["@id"])
            unique_inputs.append(inp)
    
    seen_output_ids = set()
    unique_outputs = []
    for out in outputs:
        if out["@id"] not in seen_output_ids:
            seen_output_ids.add(out["@id"])
            unique_outputs.append(out)
    
    return unique_inputs, unique_outputs

def add_inputs_outputs_to_rocrate(rocrate_path: pathlib.Path) -> Tuple[bool, str]:
    """
    Add EVI:inputs and EVI:outputs to the root dataset entity of an RO-Crate.
    
    Args:
        rocrate_path: Path to the RO-Crate directory
        
    Returns:
        Tuple of (success, message)
    """
    metadata_path = rocrate_path / "ro-crate-metadata.json"
    
    if not metadata_path.exists():
        return False, f"RO-Crate metadata file not found at {metadata_path}"
    
    try:
        with open(metadata_path, 'r') as f:
            metadata = json.load(f)
        
        graph = metadata.get("@graph", [])
        if not graph:
            return False, "RO-Crate metadata has no @graph"
        
        inputs, outputs = calculate_inputs_outputs(graph)
        
        root_dataset = None
        root_index = -1
        for i, entity in enumerate(graph):
            entity_type = entity.get("@type")
            if isinstance(entity_type, list):
                if "Dataset" in entity_type or "https://w3id.org/EVI#ROCrate" in entity_type:
                    if entity.get("@id") != "ro-crate-metadata.json":
                        root_dataset = entity
                        root_index = i
                        break
            elif entity_type == "Dataset":
                if entity.get("@id") != "ro-crate-metadata.json":
                    root_dataset = entity
                    root_index = i
                    break
        
        if root_dataset is None:
            return False, "Could not find root dataset entity in RO-Crate"
        
        root_dataset["https://w3id.org/EVI#inputs"] = inputs
        root_dataset["https://w3id.org/EVI#outputs"] = outputs
        
        graph[root_index] = root_dataset
        metadata["@graph"] = graph
        
        with open(metadata_path, 'w') as f:
            json.dump(metadata, f, indent=2)
        
        input_count = len(inputs)
        output_count = len(outputs)
        
        return True, f"Successfully added {input_count} inputs and {output_count} outputs to RO-Crate at {rocrate_path}"
        
    except json.JSONDecodeError as e:
        return False, f"Error parsing JSON: {e}"
    except Exception as e:
        return False, f"Unexpected error: {e}"